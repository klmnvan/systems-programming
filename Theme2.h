#pragma once
#define N 100
//ЗАДАНИЕ НА УКАЗАТЕЛИ

/// <summary>
/// Редактирование и вывод значения целочисленной при обращении к ней из консольного окна
/// </summary>
void T2Z1() {
	int a;
	int* pa = &a; //Тут мы задаём указателю путь к переменной
	printf("Введите целое число: ");
	scanf("%d", &a);//Тут мы впервые задаём значение переменной a, путь к которой присвоили указателю
	printf("\n");
	printf("Вы ввели %d, %d", *pa, a); //Тут мы обращаемся к указателю переменной a, и к самой переменной после изменения и смотрим, что оба значения равны
	printf("\n");
	printf("Введите целое число ещё раз: ");
	scanf("%d", &a);//Тут мы меняем именно переменную a, путь к которой присвоили указателю
	printf("\n");
	printf("Вы ввели %d, %d", *pa, a); //Тут мы обращаемся к указателю переменной a, и к самой переменной после изменения и смотрим, что оба значения равны
}

/// <summary>
/// Вывод массива, используя указатели
/// </summary>
/// <param name="arr"></param>
/// <param name="size"></param>
void showArray(int* arr, int size) {
	for (size_t i = 0; i < size; i++) {
		printf("%d\n", *arr);
		*arr++;
	}
	//Возвращать бошку не надо, потому что она сдвигалась только в контексте этой функции
}

/// <summary>
/// Динамическое создание и удаление массива из одного миллиона элементов типа int. 
/// Значения элементов массива должны быть равны значению их индексов.
/// +
/// Функция для вывода на экран консоли массива произвольной длины (сам массив передается в качестве аргумента функции)
/// </summary>
void T2Z2() {
	int* arr = malloc(N * 4);
	for (size_t i = 0; i < N; i++) *(arr+i) = i; //Обращаемся к началу массива указателей и прибавляем количество элементов, на которое нужно сдвинуть значение длля 
	/*for (size_t i = 0; i < N; i++)
	{
		printf("%d", *(arr + i));
	}*/
	showArray(arr, N);
	free(arr); //Очистили
}

/// <summary>
/// Используя указатели, сформировать треугольную матрицу следующего вида:
/// 0
/// 1 2
/// 3 4 5
/// 6 7 8 9
/// и тд.
/// </summary>
void T2Z4() {
	int n = 10;
	int count = 0;
	/* 
	//Способ первый значит, читерский
	int** arr = malloc(n * sizeof(int*)); 
	for (size_t i = 1; i <= n; i++)
	{
		int* arr2 = malloc(i * 4);
		for (size_t j = 0; j < i; j++) {
			*(arr2 + j) = count;
			printf("%d ", *(arr2 + j));
			count++;
		}
		printf("\n");
		*(arr + (i - 1)) = arr2;
	}
	*/

	//Способ второй и наверняка верный
	int** arr = malloc(n * sizeof(int*));
	int** golova1 = arr; //сохраняем голову
	for (size_t i = 1; i <= n; i++)
	{
		*arr = malloc(i * 4);
		int* golova2 = *arr;
		for (size_t j = 0; j < i; j++) 
		{
			**arr = count++; //сначала присваивание, потом ++
			(*arr)++; //обращение к указателю на первый в данный момент массив в двумерном массиве и сдвиг его на sizeof(int)
		}
		*arr++ = golova2; //сначала присваивание, потом ++ (плюсам на * пофиг)
	}

	//приколюха с передвижением указателей
	/*for (int i = 0; i < n; i++) {
		*arr = (int*)malloc((i + 1) * sizeof(int));
		int* golova2 = *arr;
		for (int j = 0; j <= i; j++) {
			*golova2 = count++;
			golova2++;
		}
		*arr++;
	}*/

	arr = golova1;
	for (size_t i = 1; i <= n; i++)
	{
		int* golova2 = *arr;
		for (size_t j = 0; j < i; j++) 
		{
			printf("%d\t", **arr);
			(*arr)++; //
		}
		printf("\n");
		*arr++ = golova2;
	}
	arr = golova1;
	int b = 5;
}

/// <summary>
/// Функция, которая выводит все числа от 0 до 4
/// </summary>
void show1() {
	for (size_t i = 0; i < 5; i++)
	{
		printf("%d ", i);
	}
}

/// <summary>
/// Функция, которая выводит квараты чисел от 0 до 4
/// </summary>
void show2() {
	for (size_t i = 0; i < 5; i++)
	{
		printf("%d ", i * i);
	}
}

/// <summary>
/// Функция, которая вызывает переданную в неё функцию типа void без аргументов
/// </summary>
/// <param name="f"></param>
void show(void (*f)()) {
	f();
}

/// <summary>
/// Написать программу с использованием указателя на функцию и 
/// с использованием указателя на функцию в качестве аргумента (можно взять пример из видео)
/// </summary>
void T2Z5() {
	void (*f1)() = show1;
	show(f1);
	printf("\n");
	void (*f2)() = show2;
	show(f2);
}
